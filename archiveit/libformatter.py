import re
import string
from Cheetah.Template import Template
from datetime import datetime, timezone
import markdown2

LIBVER = "A4.5"

thumbnails = {}
with open("archiveit/templates/thumbnails.txt", "r") as f:
    data = f.read()
    lines = data.split("\n")
thumbnails['text'] = lines[1]
thumbnails['link'] = lines[2]

class PostFormatter():
    """Parent class for all formatters.
    Formatters take Reddit posts as
    input and outputs a savable medium
    (eg. text or html)"""

    def __init__(self, post):
        self.post = post
        self.filetype = None

    def parse_comment(self, comments, lvl=0):
        li = []
        for cmt in comments:
            li.append((cmt, lvl))
            # We add an indent to the comment string relative to its reply depth,
            # add the same indent to any newlines in the string and append it
            # to our return var
            if cmt.replies is not None:
                li.extend(self.parse_comment(cmt.replies, lvl+1))

        return li

    def out(self) -> str:
        raise NotImplementedError()


class TextFormatter(PostFormatter):
    """Formats posts as plaintext."""

    def __init__(self, *args, **kwargs):
        super(TextFormatter, self).__init__(*args, **kwargs)
        self.filetype = ".txt"

    def get_author(self):
        return self.post.author.name if self.post.author is not None else "[deleted]"

    def get_title(self):
        return self.post.title if self.post.title is not None else "[deleted]"

    def get_selftext(self):
        if self.post.selftext is not None:
            lines = "-" * len(max(self.post.selftext.split("\n"), key=len))
            return "%s\n%s\n%s" % (lines, self.post.selftext, lines)
        else:
            return "---------\n[deleted]\n---------"

    def get_comments(self):

        comments = self.parse_comment(self.post.comments)
        return "".join([self.format_comment(cmt[0], cmt[1]) for cmt in comments])

    def format_comment(self, comment, lvl):
        if comment.created_utc is not None:
            time_created = str(datetime.fromtimestamp(comment.created_utc, tz = timezone.utc))
        else:
            time_created = "[unknown]"

        stri = (
                "\n\n%s" % ("\t" * lvl) +
                (comment.author.name if comment.author is not None else "[deleted]") +
                " | " +
                str(comment.score if comment.score is not None else "[deleted]") +
                " points" +
                " | on " +
                time_created +
                ("\n" + " " + comment.body).replace("\n", "\n %s" % ("\t" * lvl))
                + "\n"
        )
        return stri

    def out(self):
        self.post.comments.replace_more(limit=None)
        return (
                "Please not Windows notepad will not display indentation correctly. "
                + "Copying this into a third-party text editor (eg. notepad++) may be favorable.\n"
                + "All times are in UTC.\n\n"
                + self.get_title()
                + "\nby "
                + self.get_author()
                + " on "
                + str(datetime.fromtimestamp(self.post.created_utc, tz=timezone.utc))
                + "\n"
                + self.get_selftext()
                + "\n\nComments:"
                + self.get_comments()
                + "\n\n\n\n\n(Generated by: ArchiveIt bot %s)" % LIBVER
        )


class HTMLFormatter(PostFormatter):
    def __init__(self, *args, **kwargs):
        super(HTMLFormatter, self).__init__(*args, **kwargs)
        self.filetype = ".html"

    def get_thumbnail(self):
        if self.post.is_self:
            return thumbnails['text']
        return thumbnails['link']

    def get_image(self):
        if self.post.url.endswith('.png') or self.post.url.endswith('.jpg'):
            return self.post.url

    def markdownize(self, comment):
        words = []
        superflag = False
        for word in comment.split(" "):
            if word.startswith("^"):
                if word.startswith("^("):
                    superflag = True
                else:
                    words.append("<sup>%s</sup>" % word[1:])

            elif word is "^":
                words.append("^")

            elif "^" in word:
                chars = list(word)
                final = []
                current_phrase = []
                flag = False
                for char in chars:
                    if not flag and char is not "^":
                        final.append(char)
                    if char == "^":
                        flag = True
                        current_phrase.append("<sup>")
                    elif flag:
                        if char in string.punctuation:
                            flag = False
                            current_phrase.append("</sup>")
                            final.append("".join(current_phrase))
                            current_phrase = []
                            final.append(char)
                        else:
                            current_phrase.append(char)
                words.append("".join(final))

            else:
                if superflag:
                    words.append("<sup>%s</sup>" % word)
                    if word.endswith(")"):
                        superflag = False
                else:
                    words.append(word)

        comment = " ".join(words)
        return markdown2.markdown(comment, extras=["spoiler", "tables", "fenced-code-blocks", "strike"])

    def out(self):
        self.post.comments.replace_more(limit=None)
        data = open("archiveit/templates/reddit_template.html", "r")
        template = data.read()
        return str(Template(template,
                        searchList=[
                            {'post': self.post,
                             'time': str(datetime.fromtimestamp(self.post.created_utc, tz = timezone.utc))[:-6],
                             'image': self.get_image,
                             'thumbnail': self.get_thumbnail,
                             'markdownize': self.markdownize}
                        ]
                        ))


def get_format(stri):
    if re.match(".?[Tt]ext.?", stri) is not None:
        return TextFormatter

    elif re.match(".?[Hh]tml.?", stri) is not None:
        return HTMLFormatter

    return None

