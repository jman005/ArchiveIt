import praw
import re

LIBVER = "Alpha1.0"


class PostFormatter():
    """Parent class for all formatters.
    Formatters take Reddit posts as
    input and outputs a savable medium
    (eg. text or html)"""

    def __init__(self, post: praw.models.Submission):
        self.post = post

    def get_title(self):
        raise NotImplementedError()

    def get_author(self):
        raise NotImplementedError()

    def get_selftext(self):
        raise NotImplementedError()

    def get_comments(self):
        raise NotImplementedError()

    def out(self):
        raise NotImplementedError()


class TextFormatter(PostFormatter):
    """Formats posts as plaintext."""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.post.comments.replace_more(limit=None)

    def get_author(self):
        return self.post.author.name if self.post.author is not None else "[deleted]"

    def get_title(self):
        return self.post.title if self.post.title is not None else "[deleted]"

    def get_selftext(self):
        if self.post.selftext is not None:
            lines = "-" * len(max(self.post.selftext.split("\n"), key=len))
            return "%s\n%s\n%s" % (lines, self.post.selftext, lines)
        else:
            return "---------\n[deleted]\n---------"

    def get_comments(self):
        """Ugly recursive function...
        but it does the job. Loops
        through a CommentForest,
        checks if the comment has
        replies and if so calls the function
        on said reply."""

        def formatcmt(comment, lvl):
            # NASA has extensively researched and concluded there is no cleaner way to do this.
            stri = (
                    "\n\n%s" % ("\t" * lvl) +
                    (comment.author.name if comment.author is not None else "[deleted]") +
                    " | " +
                    str(comment.score if comment.score is not None else "[deleted]") +
                    " points" +
                    " | posted on " +
                    str(comment.created_utc if comment.created_utc is not None else "[deleted]") +
                    ("\n[" + comment.body + "]").replace("\n", "\n%s" % ("\t" * lvl))
            )
            return stri

        def parse(comments, lvl=0):
            stri = ""
            for cmt in comments:
                # We add an indent to the comment string relative to its reply depth,
                # add the same indent to any newlines in the string and append it
                # to our return var
                stri += formatcmt(cmt, lvl)
                if cmt.replies != None:
                    stri += parse(cmt.replies, lvl + 1)

            return stri

        return parse(self.post.comments)

    def out(self):
        # This isn't a very good example of a clean formatter - we do some parsing
        # in the get_ functions and some right here. However, it's still justifiable
        # for the time being as everything being returned is a string and
        # extremely easy to put together
        return (
                    "(Note: Windows notepad does not display indentation correctly. "
                    + "Copying this into a good text editor (eg. notepad++) may be favorable.)\n"
                    + self.get_title()
                    + "\nby "
                    + self.get_author()
                    + " on "
                    + str(self.post.created_utc)
                    + "\n"
                    + self.get_selftext()
                    + "\n"
                    + "\n\nComments:"
                    + self.get_comments()
                    + "\n\n\n\n\n(Generated by: ArchiveIt bot ver. %s by /u/jman005)" % LIBVER
                    )





def get_format(stri):
    if re.match(".?[Tt]ext.?", stri) is not None:
        return TextFormatter

    return None
